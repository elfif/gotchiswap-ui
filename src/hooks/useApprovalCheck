import { useState } from "react";
import { ApprovableAsset } from "../types/types";
import { TxStatus } from "../helpers/enums";
import { aavegotchiAbi } from "../abis/aavegotchi";
import { wearableAbi } from "../abis/wearables";
import { multicall, MulticallConfig } from '@wagmi/core'
import { ContractFunctionConfig } from "viem";
import { convertAddressType } from "../helpers/tools";

const AavegotchiContract = {
  address: convertAddressType(process.env.NEXT_PUBLIC_AAVEGOTCHI_CONTRACT_ADDRESS),
  abi: aavegotchiAbi
}

const WearableContract = {
  address: convertAddressType(process.env.NEXT_PUBLIC_WEARABLE_CONTRACT_ADDRESS),
  abi: wearableAbi
}

export const useApprovalCheck = () => {
  const [approvableAssets, setApprovableAssets] = useState<ApprovableAsset[]>([]);
  const [status, setStatus] = useState<TxStatus>(TxStatus.IDLE);

  const gotchis = approvableAssets
    .filter((asset) => asset.__typename === "gotchi" || asset.__typename === "portal")
    .map((gotchi) => { return { ...gotchi, approved: false } });

  const wearables = approvableAssets
    .filter((asset) => asset.__typename === "wearable")
    .map((wearable) => { return { ...wearable, approved: false } });

  const calls:ContractFunctionConfig[] = []
  
  const gotchiCalls = gotchis.map((gotchi) => {
    return {
      ...AavegotchiContract,
      functionName: 'getApproved',
      args: [gotchi.id]      
    }
  })
  calls.push(...gotchiCalls)

  if (wearables.length > 0) {
    calls.push({
      ...WearableContract,
      functionName: 'isApprovedForAll',
      args: [wearables[0].owner, process.env.NEXT_PUBLIC_OTC_CONTRACT_ADDRESS]
    })
  }

  await multicall({
    contracts: calls
  }).then((results) => {

  }

  return { approvableAssets, status };
}